import { IlpSolver } from './abstract-ilp-solver';
import { VariableName } from './model/variable-name';
import { VariableType } from './model/variable-type';
export class ArcWeightIlpSolver extends IlpSolver {
    constructor(solver$) {
        super(solver$);
        this._labelVariableMapIngoing = new Map();
        this._labelVariableMapOutgoing = new Map();
        this._inverseLabelVariableMapIngoing = new Map();
        this._inverseLabelVariableMapOutgoing = new Map();
    }
    transitionVariableName(label, prefix) {
        let map, inverseMap;
        if (prefix === VariableName.INGOING_ARC_WEIGHT_PREFIX) {
            map = this._labelVariableMapIngoing;
            inverseMap = this._inverseLabelVariableMapIngoing;
        }
        else {
            map = this._labelVariableMapOutgoing;
            inverseMap = this._inverseLabelVariableMapOutgoing;
        }
        const saved = map.get(label);
        if (saved !== undefined) {
            return saved;
        }
        const name = this.helperVariableName(prefix);
        map.set(label, name);
        inverseMap.set(name, label);
        return name;
    }
    getInverseVariableMapping(variable) {
        if (variable === VariableName.INITIAL_MARKING) {
            return {
                label: VariableName.INITIAL_MARKING,
                type: VariableType.INITIAL_MARKING
            };
        }
        else if (variable.startsWith(VariableName.INGOING_ARC_WEIGHT_PREFIX)) {
            const label = this._inverseLabelVariableMapIngoing.get(variable);
            if (label === undefined) {
                throw new Error(`ILP variable '${variable}' could not be resolved to an ingoing transition label!`);
            }
            return {
                label,
                type: VariableType.INGOING_WEIGHT
            };
        }
        else {
            const label = this._inverseLabelVariableMapOutgoing.get(variable);
            if (label === undefined) {
                throw new Error(`ILP variable '${variable}' could not be resolved to an outgoing transition label!`);
            }
            return {
                label,
                type: VariableType.OUTGOING_WEIGHT
            };
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXJjV2VpZ2h0SWxwU29sdmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29tcG9uZW50cy9zcmMvbGliL3V0aWxpdHkvZ2xway9BcmNXZWlnaHRJbHBTb2x2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBR2hELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVuRCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHbkQsTUFBTSxPQUFnQixrQkFBbUIsU0FBUSxTQUFTO0lBT3RELFlBQXNCLE9BQXlCO1FBQzNDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztRQUMxRCxJQUFJLENBQUMseUJBQXlCLEdBQUcsSUFBSSxHQUFHLEVBQWtCLENBQUM7UUFDM0QsSUFBSSxDQUFDLCtCQUErQixHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO1FBQ2pFLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztJQUN0RSxDQUFDO0lBRVMsc0JBQXNCLENBQUMsS0FBYSxFQUFFLE1BQWlCO1FBQzdELElBQUksR0FBRyxFQUFFLFVBQVUsQ0FBQztRQUNwQixJQUFJLE1BQU0sS0FBSyxZQUFZLENBQUMseUJBQXlCLEVBQUU7WUFDbkQsR0FBRyxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztZQUNwQyxVQUFVLEdBQUcsSUFBSSxDQUFDLCtCQUErQixDQUFDO1NBQ3JEO2FBQU07WUFDSCxHQUFHLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDO1lBQ3JDLFVBQVUsR0FBRyxJQUFJLENBQUMsZ0NBQWdDLENBQUM7U0FDdEQ7UUFDRCxNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUNyQixPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNyQixVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM1QixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRU0seUJBQXlCLENBQUMsUUFBZ0I7UUFDN0MsSUFBSSxRQUFRLEtBQUssWUFBWSxDQUFDLGVBQWUsRUFBRTtZQUMzQyxPQUFPO2dCQUNILEtBQUssRUFBRSxZQUFZLENBQUMsZUFBZTtnQkFDbkMsSUFBSSxFQUFFLFlBQVksQ0FBQyxlQUFlO2FBQ3JDLENBQUE7U0FDSjthQUFNLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMseUJBQXlCLENBQUMsRUFBRTtZQUNwRSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsK0JBQStCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ2pFLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtnQkFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsUUFBUSx5REFBeUQsQ0FBQyxDQUFDO2FBQ3ZHO1lBQ0QsT0FBTztnQkFDSCxLQUFLO2dCQUNMLElBQUksRUFBRSxZQUFZLENBQUMsY0FBYzthQUNwQyxDQUFBO1NBQ0o7YUFBTTtZQUNILE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbEUsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO2dCQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixRQUFRLDBEQUEwRCxDQUFDLENBQUM7YUFDeEc7WUFDRCxPQUFPO2dCQUNILEtBQUs7Z0JBQ0wsSUFBSSxFQUFFLFlBQVksQ0FBQyxlQUFlO2FBQ3JDLENBQUE7U0FDSjtJQUNMLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SWxwU29sdmVyfSBmcm9tICcuL2Fic3RyYWN0LWlscC1zb2x2ZXInO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge0dMUEt9IGZyb20gJ2dscGsuanMnO1xyXG5pbXBvcnQge1ZhcmlhYmxlTmFtZX0gZnJvbSAnLi9tb2RlbC92YXJpYWJsZS1uYW1lJztcclxuaW1wb3J0IHtTb2x1dGlvblZhcmlhYmxlfSBmcm9tICcuL21vZGVsL3NvbHV0aW9uLXZhcmlhYmxlJztcclxuaW1wb3J0IHtWYXJpYWJsZVR5cGV9IGZyb20gJy4vbW9kZWwvdmFyaWFibGUtdHlwZSc7XHJcblxyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFyY1dlaWdodElscFNvbHZlciBleHRlbmRzIElscFNvbHZlciB7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfbGFiZWxWYXJpYWJsZU1hcEluZ29pbmc6IE1hcDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9sYWJlbFZhcmlhYmxlTWFwT3V0Z29pbmc6IE1hcDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pbnZlcnNlTGFiZWxWYXJpYWJsZU1hcEluZ29pbmc6IE1hcDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pbnZlcnNlTGFiZWxWYXJpYWJsZU1hcE91dGdvaW5nOiBNYXA8c3RyaW5nLCBzdHJpbmc+O1xyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihzb2x2ZXIkOiBPYnNlcnZhYmxlPEdMUEs+KSB7XHJcbiAgICAgICAgc3VwZXIoc29sdmVyJCk7XHJcbiAgICAgICAgdGhpcy5fbGFiZWxWYXJpYWJsZU1hcEluZ29pbmcgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xyXG4gICAgICAgIHRoaXMuX2xhYmVsVmFyaWFibGVNYXBPdXRnb2luZyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XHJcbiAgICAgICAgdGhpcy5faW52ZXJzZUxhYmVsVmFyaWFibGVNYXBJbmdvaW5nID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgICAgICB0aGlzLl9pbnZlcnNlTGFiZWxWYXJpYWJsZU1hcE91dGdvaW5nID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgdHJhbnNpdGlvblZhcmlhYmxlTmFtZShsYWJlbDogc3RyaW5nLCBwcmVmaXg6ICd4JyB8ICd5Jyk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IG1hcCwgaW52ZXJzZU1hcDtcclxuICAgICAgICBpZiAocHJlZml4ID09PSBWYXJpYWJsZU5hbWUuSU5HT0lOR19BUkNfV0VJR0hUX1BSRUZJWCkge1xyXG4gICAgICAgICAgICBtYXAgPSB0aGlzLl9sYWJlbFZhcmlhYmxlTWFwSW5nb2luZztcclxuICAgICAgICAgICAgaW52ZXJzZU1hcCA9IHRoaXMuX2ludmVyc2VMYWJlbFZhcmlhYmxlTWFwSW5nb2luZztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXAgPSB0aGlzLl9sYWJlbFZhcmlhYmxlTWFwT3V0Z29pbmc7XHJcbiAgICAgICAgICAgIGludmVyc2VNYXAgPSB0aGlzLl9pbnZlcnNlTGFiZWxWYXJpYWJsZU1hcE91dGdvaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzYXZlZCA9IG1hcC5nZXQobGFiZWwpO1xyXG4gICAgICAgIGlmIChzYXZlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzYXZlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuaGVscGVyVmFyaWFibGVOYW1lKHByZWZpeCk7XHJcbiAgICAgICAgbWFwLnNldChsYWJlbCwgbmFtZSk7XHJcbiAgICAgICAgaW52ZXJzZU1hcC5zZXQobmFtZSwgbGFiZWwpO1xyXG4gICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRJbnZlcnNlVmFyaWFibGVNYXBwaW5nKHZhcmlhYmxlOiBzdHJpbmcpOiBTb2x1dGlvblZhcmlhYmxlIHtcclxuICAgICAgICBpZiAodmFyaWFibGUgPT09IFZhcmlhYmxlTmFtZS5JTklUSUFMX01BUktJTkcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBWYXJpYWJsZU5hbWUuSU5JVElBTF9NQVJLSU5HLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogVmFyaWFibGVUeXBlLklOSVRJQUxfTUFSS0lOR1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YXJpYWJsZS5zdGFydHNXaXRoKFZhcmlhYmxlTmFtZS5JTkdPSU5HX0FSQ19XRUlHSFRfUFJFRklYKSkge1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuX2ludmVyc2VMYWJlbFZhcmlhYmxlTWFwSW5nb2luZy5nZXQodmFyaWFibGUpO1xyXG4gICAgICAgICAgICBpZiAobGFiZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJTFAgdmFyaWFibGUgJyR7dmFyaWFibGV9JyBjb3VsZCBub3QgYmUgcmVzb2x2ZWQgdG8gYW4gaW5nb2luZyB0cmFuc2l0aW9uIGxhYmVsIWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFZhcmlhYmxlVHlwZS5JTkdPSU5HX1dFSUdIVFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLl9pbnZlcnNlTGFiZWxWYXJpYWJsZU1hcE91dGdvaW5nLmdldCh2YXJpYWJsZSk7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElMUCB2YXJpYWJsZSAnJHt2YXJpYWJsZX0nIGNvdWxkIG5vdCBiZSByZXNvbHZlZCB0byBhbiBvdXRnb2luZyB0cmFuc2l0aW9uIGxhYmVsIWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFZhcmlhYmxlVHlwZS5PVVRHT0lOR19XRUlHSFRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=