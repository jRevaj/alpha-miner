import { ArcWeightIlpSolver } from '../../../../utility/glpk/ArcWeightIlpSolver';
import { concatMap, from, toArray } from 'rxjs';
import { TraceMultisetEquivalentStateTraverser } from '../../../../utility/multiset/trace-multiset-equivalent-state-traverser';
import { mapMultiset } from '../../../../utility/multiset/multiset';
import { Goal } from '../../../../models/glpk/glpk-constants';
import { VariableName } from '../../../../utility/glpk/model/variable-name';
import { DirectlyFollowsExtractor } from '../../../../utility/directly-follows-extractor';
export class IlpMinerIlpSolver extends ArcWeightIlpSolver {
    constructor(solver$) {
        super(solver$);
    }
    findSolutions(log) {
        const baseIlpConstraints = [];
        const directlyFollowsExtractor = new DirectlyFollowsExtractor();
        const traverser = new TraceMultisetEquivalentStateTraverser();
        traverser.traverseMultisetEquivalentStates(log, (prefix, step) => {
            baseIlpConstraints.push(...this.firingRule(prefix, step));
        }, (prefix, step) => {
            if (prefix.length === 0) {
                return;
            }
            directlyFollowsExtractor.add(step, prefix[prefix.length - 1]);
        });
        const oneWayDirectlyFollowsPairs = directlyFollowsExtractor.oneWayDirectlyFollows();
        const baseIlp = this.setUpBaseIlp();
        const problems = oneWayDirectlyFollowsPairs.map(pair => ({
            baseIlpConstraints,
            baseIlp,
            pair
        }));
        return from(problems).pipe(concatMap(problem => {
            return this.solveILP(this.populateIlp(problem.baseIlp, problem.baseIlpConstraints, problem.pair));
        }), toArray());
    }
    firingRule(prefix, step) {
        let foundStep = false;
        const variables = mapMultiset(prefix, (name, cardinality) => {
            const result = [this.variable(this.transitionVariableName(name, VariableName.OUTGOING_ARC_WEIGHT_PREFIX), cardinality)];
            let c = cardinality;
            if (name === step) {
                c += 1;
                foundStep = true;
            }
            result.push(this.variable(this.transitionVariableName(name, VariableName.INGOING_ARC_WEIGHT_PREFIX), -c));
            return result;
        }).reduce((accumulator, value) => accumulator.concat(value), []);
        if (!foundStep) {
            variables.push(this.variable(this.transitionVariableName(step, VariableName.INGOING_ARC_WEIGHT_PREFIX), -1));
        }
        variables.push(this.variable(VariableName.INITIAL_MARKING));
        return this.greaterEqualThan(variables, 0).constraints;
    }
    setUpBaseIlp() {
        const allVariables = Array.from(this._allVariables).concat(VariableName.INITIAL_MARKING);
        return {
            name: 'ilp',
            objective: {
                name: 'goal',
                direction: Goal.MINIMUM,
                vars: allVariables.map(v => {
                    let coef;
                    if (v.startsWith(VariableName.INITIAL_MARKING)) {
                        coef = 30;
                    }
                    else if (v.startsWith(VariableName.OUTGOING_ARC_WEIGHT_PREFIX)) {
                        coef = 10;
                    }
                    else {
                        coef = -1;
                    }
                    return this.variable(v, coef);
                })
            },
            subjectTo: [],
            // TODO enable arc weights with a config setting?
            binaries: allVariables
        };
    }
    populateIlp(baseIlp, baseConstraints, causalPair) {
        const result = Object.assign({}, baseIlp);
        result.subjectTo = [...baseConstraints];
        result.subjectTo = result.subjectTo.concat(this.greaterEqualThan(this.variable(this.transitionVariableName(causalPair[0], VariableName.OUTGOING_ARC_WEIGHT_PREFIX)), 1).constraints);
        result.subjectTo = result.subjectTo.concat(this.greaterEqualThan(this.variable(this.transitionVariableName(causalPair[1], VariableName.INGOING_ARC_WEIGHT_PREFIX)), 1).constraints);
        return result;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWxwLW1pbmVyLWlscC1zb2x2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21wb25lbnRzL3NyYy9saWIvYWxnb3JpdGhtcy9wbi9zeW50aGVzaXMvaWxwLW1pbmVyL2lscC1taW5lci1pbHAtc29sdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLDZDQUE2QyxDQUFDO0FBQy9FLE9BQU8sRUFBQyxTQUFTLEVBQUUsSUFBSSxFQUFjLE9BQU8sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUcxRCxPQUFPLEVBQ0gscUNBQXFDLEVBQ3hDLE1BQU0sd0VBQXdFLENBQUM7QUFFaEYsT0FBTyxFQUFDLFdBQVcsRUFBVyxNQUFNLHVDQUF1QyxDQUFDO0FBRTVFLE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSx3Q0FBd0MsQ0FBQztBQUU1RCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sOENBQThDLENBQUM7QUFDMUUsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sZ0RBQWdELENBQUM7QUFHeEYsTUFBTSxPQUFPLGlCQUFrQixTQUFRLGtCQUFrQjtJQUVyRCxZQUFZLE9BQXlCO1FBQ2pDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRU0sYUFBYSxDQUFDLEdBQWlCO1FBQ2xDLE1BQU0sa0JBQWtCLEdBQXFCLEVBQUUsQ0FBQztRQUNoRCxNQUFNLHdCQUF3QixHQUFHLElBQUksd0JBQXdCLEVBQUUsQ0FBQztRQUVoRSxNQUFNLFNBQVMsR0FBRyxJQUFJLHFDQUFxQyxFQUFFLENBQUM7UUFDOUQsU0FBUyxDQUFDLGdDQUFnQyxDQUFDLEdBQUcsRUFDMUMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDYixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFB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UyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLHlCQUF5QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNwTCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FyY1dlaWdodElscFNvbHZlcn0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0eS9nbHBrL0FyY1dlaWdodElscFNvbHZlcic7XHJcbmltcG9ydCB7Y29uY2F0TWFwLCBmcm9tLCBPYnNlcnZhYmxlLCB0b0FycmF5fSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtHTFBLLCBMUH0gZnJvbSAnZ2xway5qcyc7XHJcbmltcG9ydCB7VHJhY2V9IGZyb20gJy4uLy4uLy4uLy4uL21vZGVscy9sb2cvbW9kZWwvdHJhY2UnO1xyXG5pbXBvcnQge1xyXG4gICAgVHJhY2VNdWx0aXNldEVxdWl2YWxlbnRTdGF0ZVRyYXZlcnNlclxyXG59IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxpdHkvbXVsdGlzZXQvdHJhY2UtbXVsdGlzZXQtZXF1aXZhbGVudC1zdGF0ZS10cmF2ZXJzZXInO1xyXG5pbXBvcnQge1N1YmplY3RUb30gZnJvbSAnLi4vLi4vLi4vLi4vbW9kZWxzL2dscGsvc3ViamVjdC10byc7XHJcbmltcG9ydCB7bWFwTXVsdGlzZXQsIE11bHRpc2V0fSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXR5L211bHRpc2V0L211bHRpc2V0JztcclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSAnLi4vLi4vLi4vLi4vbW9kZWxzL2dscGsvdmFyaWFibGUnO1xyXG5pbXBvcnQge0dvYWx9IGZyb20gJy4uLy4uLy4uLy4uL21vZGVscy9nbHBrL2dscGstY29uc3RhbnRzJztcclxuaW1wb3J0IHtQcm9ibGVtU29sdXRpb259IGZyb20gJy4uLy4uLy4uLy4uL21vZGVscy9nbHBrL3Byb2JsZW0tc29sdXRpb24nO1xyXG5pbXBvcnQge1ZhcmlhYmxlTmFtZX0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0eS9nbHBrL21vZGVsL3ZhcmlhYmxlLW5hbWUnO1xyXG5pbXBvcnQge0RpcmVjdGx5Rm9sbG93c0V4dHJhY3Rvcn0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0eS9kaXJlY3RseS1mb2xsb3dzLWV4dHJhY3Rvcic7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIElscE1pbmVySWxwU29sdmVyIGV4dGVuZHMgQXJjV2VpZ2h0SWxwU29sdmVyIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihzb2x2ZXIkOiBPYnNlcnZhYmxlPEdMUEs+KSB7XHJcbiAgICAgICAgc3VwZXIoc29sdmVyJCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGZpbmRTb2x1dGlvbnMobG9nOiBBcnJheTxUcmFjZT4pOiBPYnNlcnZhYmxlPEFycmF5PFByb2JsZW1Tb2x1dGlvbj4+IHtcclxuICAgICAgICBjb25zdCBiYXNlSWxwQ29uc3RyYWludHM6IEFycmF5PFN1YmplY3RUbz4gPSBbXTtcclxuICAgICAgICBjb25zdCBkaXJlY3RseUZvbGxvd3NFeHRyYWN0b3IgPSBuZXcgRGlyZWN0bHlGb2xsb3dzRXh0cmFjdG9yKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYXZlcnNlciA9IG5ldyBUcmFjZU11bHRpc2V0RXF1aXZhbGVudFN0YXRlVHJhdmVyc2VyKCk7XHJcbiAgICAgICAgdHJhdmVyc2VyLnRyYXZlcnNlTXVsdGlzZXRFcXVpdmFsZW50U3RhdGVzKGxvZyxcclxuICAgICAgICAgICAgKHByZWZpeCwgc3RlcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYmFzZUlscENvbnN0cmFpbnRzLnB1c2goLi4udGhpcy5maXJpbmdSdWxlKHByZWZpeCwgc3RlcCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAocHJlZml4LCBzdGVwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRpcmVjdGx5Rm9sbG93c0V4dHJhY3Rvci5hZGQoc3RlcCwgcHJlZml4W3ByZWZpeC5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBvbmVXYXlEaXJlY3RseUZvbGxvd3NQYWlycyA9IGRpcmVjdGx5Rm9sbG93c0V4dHJhY3Rvci5vbmVXYXlEaXJlY3RseUZvbGxvd3MoKTtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZUlscCA9IHRoaXMuc2V0VXBCYXNlSWxwKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2JsZW1zID0gb25lV2F5RGlyZWN0bHlGb2xsb3dzUGFpcnMubWFwKHBhaXIgPT4gKHtcclxuICAgICAgICAgICAgYmFzZUlscENvbnN0cmFpbnRzLFxyXG4gICAgICAgICAgICBiYXNlSWxwLFxyXG4gICAgICAgICAgICBwYWlyXHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnJvbShwcm9ibGVtcykucGlwZShcclxuICAgICAgICAgICAgY29uY2F0TWFwKHByb2JsZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29sdmVJTFAodGhpcy5wb3B1bGF0ZUlscChwcm9ibGVtLmJhc2VJbHAsIHByb2JsZW0uYmFzZUlscENvbnN0cmFpbnRzLCBwcm9ibGVtLnBhaXIpKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHRvQXJyYXkoKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBmaXJpbmdSdWxlKHByZWZpeDogTXVsdGlzZXQsIHN0ZXA6IHN0cmluZyk6IEFycmF5PFN1YmplY3RUbz4ge1xyXG4gICAgICAgIGxldCBmb3VuZFN0ZXAgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBtYXBNdWx0aXNldDxBcnJheTxWYXJpYWJsZT4+KHByZWZpeCwgKG5hbWUsIGNhcmRpbmFsaXR5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFt0aGlzLnZhcmlhYmxlKHRoaXMudHJhbnNpdGlvblZhcmlhYmxlTmFtZShuYW1lLCBWYXJpYWJsZU5hbWUuT1VUR09JTkdfQVJDX1dFSUdIVF9QUkVGSVgpLCBjYXJkaW5hbGl0eSldO1xyXG4gICAgICAgICAgICBsZXQgYyA9IGNhcmRpbmFsaXR5O1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgYyArPSAxO1xyXG4gICAgICAgICAgICAgICAgZm91bmRTdGVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnZhcmlhYmxlKHRoaXMudHJhbnNpdGlvblZhcmlhYmxlTmFtZShuYW1lLCBWYXJpYWJsZU5hbWUuSU5HT0lOR19BUkNfV0VJR0hUX1BSRUZJWCksIC1jKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSkucmVkdWNlKChhY2N1bXVsYXRvciwgdmFsdWUpID0+IGFjY3VtdWxhdG9yLmNvbmNhdCh2YWx1ZSksIFtdKTtcclxuXHJcbiAgICAgICAgaWYgKCFmb3VuZFN0ZXApIHtcclxuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2godGhpcy52YXJpYWJsZSh0aGlzLnRyYW5zaXRpb25WYXJpYWJsZU5hbWUoc3RlcCwgVmFyaWFibGVOYW1lLklOR09JTkdfQVJDX1dFSUdIVF9QUkVGSVgpLCAtMSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyaWFibGVzLnB1c2godGhpcy52YXJpYWJsZShWYXJpYWJsZU5hbWUuSU5JVElBTF9NQVJLSU5HKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdyZWF0ZXJFcXVhbFRoYW4odmFyaWFibGVzLCAwKS5jb25zdHJhaW50cztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldFVwQmFzZUlscCgpOiBMUCB7XHJcbiAgICAgICAgY29uc3QgYWxsVmFyaWFibGVzID0gQXJyYXkuZnJvbSh0aGlzLl9hbGxWYXJpYWJsZXMpLmNvbmNhdChWYXJpYWJsZU5hbWUuSU5JVElBTF9NQVJLSU5HKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lOiAnaWxwJyxcclxuICAgICAgICAgICAgb2JqZWN0aXZlOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnZ29hbCcsXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IEdvYWwuTUlOSU1VTSxcclxuICAgICAgICAgICAgICAgIHZhcnM6IGFsbFZhcmlhYmxlcy5tYXAodiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuc3RhcnRzV2l0aChWYXJpYWJsZU5hbWUuSU5JVElBTF9NQVJLSU5HKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmID0gMzA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnN0YXJ0c1dpdGgoVmFyaWFibGVOYW1lLk9VVEdPSU5HX0FSQ19XRUlHSFRfUFJFRklYKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmID0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29lZiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZSh2LCBjb2VmKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN1YmplY3RUbzogW10sXHJcbiAgICAgICAgICAgIC8vIFRPRE8gZW5hYmxlIGFyYyB3ZWlnaHRzIHdpdGggYSBjb25maWcgc2V0dGluZz9cclxuICAgICAgICAgICAgYmluYXJpZXM6IGFsbFZhcmlhYmxlc1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwb3B1bGF0ZUlscChiYXNlSWxwOiBMUCwgYmFzZUNvbnN0cmFpbnRzOiBBcnJheTxTdWJqZWN0VG8+LCBjYXVzYWxQYWlyOiBBcnJheTxzdHJpbmc+KTogTFAge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJbHApO1xyXG4gICAgICAgIHJlc3VsdC5zdWJqZWN0VG8gPSBbLi4uYmFzZUNvbnN0cmFpbnRzXTtcclxuICAgICAgICByZXN1bHQuc3ViamVjdFRvID0gcmVzdWx0LnN1YmplY3RUby5jb25jYXQodGhpcy5ncmVhdGVyRXF1YWxUaGFuKHRoaXMudmFyaWFibGUodGhpcy50cmFuc2l0aW9uVmFyaWFibGVOYW1lKGNhdXNhbFBhaXJbMF0sIFZhcmlhYmxlTmFtZS5PVVRHT0lOR19BUkNfV0VJR0hUX1BSRUZJWCkpLCAxKS5jb25zdHJhaW50cyk7XHJcbiAgICAgICAgcmVzdWx0LnN1YmplY3RUbyA9IHJlc3VsdC5zdWJqZWN0VG8uY29uY2F0KHRoaXMuZ3JlYXRlckVxdWFsVGhhbih0aGlzLnZhcmlhYmxlKHRoaXMudHJhbnNpdGlvblZhcmlhYmxlTmFtZShjYXVzYWxQYWlyWzFdLCBWYXJpYWJsZU5hbWUuSU5HT0lOR19BUkNfV0VJR0hUX1BSRUZJWCkpLCAxKS5jb25zdHJhaW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4iXX0=