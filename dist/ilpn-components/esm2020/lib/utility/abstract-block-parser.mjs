import { AbstractParser } from './abstract-parser';
export class AbstractBlockParser extends AbstractParser {
    constructor(allowedTypes, supportedBlocks) {
        super(allowedTypes);
        this._supportedBlocks = supportedBlocks;
    }
    processFileLines(lines) {
        const result = this.newResult();
        let currentBlock = undefined;
        let blockStart = -1;
        try {
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trimEnd();
                if (!line.startsWith('.')) {
                    continue;
                }
                const newBlock = this._supportedBlocks.find(block => line.startsWith(block));
                if (newBlock === undefined) {
                    console.debug(`ignoring unsupported block on line ${i}: '${line}'`);
                    continue;
                }
                this.parseBlock(currentBlock, blockStart, i, lines, result);
                blockStart = i + 1;
                currentBlock = newBlock;
            }
            this.parseBlock(currentBlock, blockStart, lines.length, lines, result);
        }
        catch (e) {
            console.error(e.message);
            return undefined;
        }
        return result;
    }
    parseEachLine(lines, partParser) {
        for (let i = 0; i < lines.length; i++) {
            const line = this.getLineTrimEnd(lines, i);
            if (line.length === 0) {
                continue;
            }
            const parts = line.split(' ');
            partParser(parts, line);
        }
    }
    getLineTrimEnd(lines, index) {
        return lines[index].trimEnd();
    }
    parseBlock(currentBlock, blockStart, blockEnd, lines, result) {
        if (currentBlock !== undefined) {
            const blockParser = this.resolveBlockParser(currentBlock);
            if (blockParser === undefined) {
                throw new Error(`block type '${currentBlock}' is suppoerted but no block parser could be resolved!`);
            }
            blockParser(lines.slice(blockStart, blockEnd), result);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtYmxvY2stcGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29tcG9uZW50cy9zcmMvbGliL3V0aWxpdHkvYWJzdHJhY3QtYmxvY2stcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUVqRCxNQUFNLE9BQWdCLG1CQUF1QixTQUFRLGNBQWlCO0lBSWxFLFlBQXNCLFlBQW9DLEVBQUUsZUFBOEI7UUFDdEYsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxlQUFlLENBQUM7SUFDNUMsQ0FBQztJQUVrQixnQkFBZ0IsQ0FBQyxLQUFvQjtRQUNwRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFFaEMsSUFBSSxZQUFZLEdBQXVCLFNBQVMsQ0FBQztRQUNqRCxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUVwQixJQUFJO1lBQ0EsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ25DLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ3ZCLFNBQVM7aUJBQ1o7Z0JBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDN0UsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO29CQUN4QixPQUFPLENBQUMsS0FBSyxDQUFDLHNDQUFzQyxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQztvQkFDcEUsU0FBUztpQkFDWjtnQkFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFFNUQsVUFBVSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ25CLFlBQVksR0FBRyxRQUFRLENBQUM7YUFDM0I7WUFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDMUU7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNSLE9BQU8sQ0FBQyxLQUFLLENBQUUsQ0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3BDLE9BQU8sU0FBUyxDQUFDO1NBQ3BCO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQU1TLGFBQWEsQ0FBQyxLQUFvQixFQUFFLFVBQXdEO1FBQ2xHLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ25DLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ25CLFNBQVM7YUFDWjtZQUNELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDOUIsVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztTQUMzQjtJQUNMLENBQUM7SUFFUyxjQUFjLENBQUMsS0FBb0IsRUFBRSxLQUFhO1FBQ3hELE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFTyxVQUFVLENBQUMsWUFBZ0MsRUFBRSxVQUFrQixFQUFFLFFBQWdCLEVBQUUsS0FBb0IsRUFBRSxNQUFTO1FBQ3RILElBQUksWUFBWSxLQUFLLFNBQVMsRUFBRTtZQUM1QixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDMUQsSUFBSSxXQUFXLEtBQUssU0FBUyxFQUFFO2dCQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLGVBQWUsWUFBWSx3REFBd0QsQ0FBQyxDQUFDO2FBQ3hHO1lBQ0QsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzFEO0lBQ0wsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtBYnN0cmFjdFBhcnNlcn0gZnJvbSAnLi9hYnN0cmFjdC1wYXJzZXInO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0QmxvY2tQYXJzZXI8VD4gZXh0ZW5kcyBBYnN0cmFjdFBhcnNlcjxUPiB7XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdXBwb3J0ZWRCbG9ja3M6IEFycmF5PHN0cmluZz47XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGFsbG93ZWRUeXBlczogQXJyYXk8c3RyaW5nPiB8IHN0cmluZywgc3VwcG9ydGVkQmxvY2tzOiBBcnJheTxzdHJpbmc+KSB7XHJcbiAgICAgICAgc3VwZXIoYWxsb3dlZFR5cGVzKTtcclxuICAgICAgICB0aGlzLl9zdXBwb3J0ZWRCbG9ja3MgPSBzdXBwb3J0ZWRCbG9ja3M7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIHByb2Nlc3NGaWxlTGluZXMobGluZXM6IEFycmF5PHN0cmluZz4pOiBUIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm5ld1Jlc3VsdCgpO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVudEJsb2NrOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGJsb2NrU3RhcnQgPSAtMTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW1FbmQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKCcuJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdCbG9jayA9IHRoaXMuX3N1cHBvcnRlZEJsb2Nrcy5maW5kKGJsb2NrID0+IGxpbmUuc3RhcnRzV2l0aChibG9jaykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0Jsb2NrID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBpZ25vcmluZyB1bnN1cHBvcnRlZCBibG9jayBvbiBsaW5lICR7aX06ICcke2xpbmV9J2ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VCbG9jayhjdXJyZW50QmxvY2ssIGJsb2NrU3RhcnQsIGksIGxpbmVzLCByZXN1bHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJsb2NrU3RhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9jayA9IG5ld0Jsb2NrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VCbG9jayhjdXJyZW50QmxvY2ssIGJsb2NrU3RhcnQsIGxpbmVzLmxlbmd0aCwgbGluZXMsIHJlc3VsdCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKChlIGFzIEVycm9yKS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IG5ld1Jlc3VsdCgpOiBUO1xyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZXNvbHZlQmxvY2tQYXJzZXIoYmxvY2s6IHN0cmluZyk6IHVuZGVmaW5lZCB8ICgobGluZXM6IEFycmF5PHN0cmluZz4sIHJlc3VsdDogVCkgPT4gdm9pZCk7XHJcblxyXG4gICAgcHJvdGVjdGVkIHBhcnNlRWFjaExpbmUobGluZXM6IEFycmF5PHN0cmluZz4sIHBhcnRQYXJzZXI6IChwYXJ0czogQXJyYXk8c3RyaW5nPiwgbGluZTogc3RyaW5nKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lVHJpbUVuZChsaW5lcywgaSk7XHJcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIHBhcnRQYXJzZXIocGFydHMsIGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0TGluZVRyaW1FbmQobGluZXM6IEFycmF5PHN0cmluZz4sIGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBsaW5lc1tpbmRleF0udHJpbUVuZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcGFyc2VCbG9jayhjdXJyZW50QmxvY2s6IHN0cmluZyB8IHVuZGVmaW5lZCwgYmxvY2tTdGFydDogbnVtYmVyLCBibG9ja0VuZDogbnVtYmVyLCBsaW5lczogQXJyYXk8c3RyaW5nPiwgcmVzdWx0OiBUKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRCbG9jayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrUGFyc2VyID0gdGhpcy5yZXNvbHZlQmxvY2tQYXJzZXIoY3VycmVudEJsb2NrKTtcclxuICAgICAgICAgICAgaWYgKGJsb2NrUGFyc2VyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmxvY2sgdHlwZSAnJHtjdXJyZW50QmxvY2t9JyBpcyBzdXBwb2VydGVkIGJ1dCBubyBibG9jayBwYXJzZXIgY291bGQgYmUgcmVzb2x2ZWQhYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmxvY2tQYXJzZXIobGluZXMuc2xpY2UoYmxvY2tTdGFydCwgYmxvY2tFbmQpLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=